@inherits TestContext
@using Blazor.FamilyTreeJS.Components
@using NSubstitute

@code
{
  private const string FamilyTreeJsInteropModule = "FamilyTreeJsInteropObj";

  private const string ModulePath =
    "./_content/Blazor.FamilyTreeJS/js/Components/Interop/Modules/FamilyTreeInterop/family-tree-interop.js";

  private readonly BunitJSModuleInterop _mockJsModule;

  /// <summary>
  /// Some tests may not need to call DisposeComponents at the end,
  /// hence you can use this field to control when to call DisposeComponents.
  /// </summary>
  private bool _shouldDispose;

  public FamilyTreeTests()
  {
    _shouldDispose = true;

    Services.AddBlazorFamilyJS();
    _mockJsModule = JSInterop.SetupModule(ModulePath);
    _mockJsModule
      .Setup<bool>($"{FamilyTreeJsInteropModule}.treeExist", _ => true)
      .SetResult(false);

    _mockJsModule
      .SetupVoid($"{FamilyTreeJsInteropModule}.setupFamilyTree", _ => true)
      .SetVoidResult();

    _mockJsModule
      .SetupVoid($"{FamilyTreeJsInteropModule}.registerUpdateNodeHandler", _ => true)
      .SetVoidResult();

    _mockJsModule
      .SetupVoid($"{FamilyTreeJsInteropModule}.destroyTree", _ => true)
      .SetVoidResult();
  }

  protected override void Dispose(bool disposing)
  {
    if (_shouldDispose)
    {
      DisposeComponents();
    }
    base.Dispose(disposing);
  }

  [Fact]
  public void FamilyTree_EmptyTreeId_ThrowsException()
  {
    Assert.Throws<ArgumentException>(() => Render(@<FamilyTree TreeId=@string.Empty />));
    _shouldDispose = false;
  }

  [Fact]
  public void FamilyTree_ValidTreeId_RendersDiv()
  {
    // Arrange
    const string style = "width: 50%; height: 50%;";
    const string treeId = "test";

    // Act
    var cut = Render(@<FamilyTree TreeId=@treeId Style=@style />);

    // Assert
    var div = cut.Find("div");
    Assert.NotNull(div);

    var attrbs = div.Attributes
      .ToDictionary(attrb => attrb.Name, attrb => attrb.Value);

    Assert.Contains("style", attrbs);
    Assert.Equal(style, attrbs["style"]);

    Assert.Contains("id", attrbs);
    Assert.Equal($"tree-{treeId}", attrbs["id"]);
  }

  [Fact]
  public void FamilyTree_SameTreeId_ThrowsException()
  {
    // Arrange
    const string treeId = "test";

    _mockJsModule
      .Setup<bool>($"{FamilyTreeJsInteropModule}.treeExist", _ => true)
      .SetResult(true);

    // Act & Assert
    Assert.Throws<ArgumentException>(() => Render(@<FamilyTree TreeId=@treeId />));
  }

  [Fact]
  public void FamilyTree_RegisterAfterFamilyTreeRenderCallback_CallbackIsInvoked()
  {
    // Arrange
    var actionSub = Substitute.For<Action>();

    // Act
    var cut = Render(@<FamilyTree TreeId="test" AfterFamilyTreeRender=@actionSub />);

    // Arrange
    actionSub.ReceivedWithAnyArgs().Invoke();
  }

  [Fact]
  public void FamilyTree_RegisterAfterFamilyTreeRenderAsyncCallback_CallbackIsInvoked()
  {
    // Arrange
    var funcSub = Substitute.For<Func<Task>>();

    // Act
    var cut = Render(@<FamilyTree TreeId="test" AfterFamilyTreeRenderAsync=@funcSub />);

    // Arrange
    funcSub.ReceivedWithAnyArgs().Invoke();
  }

  [Fact]
  public void FamilyTree_RegisterBothAfterFamilyTreeRenderCallbacks_CallbacksIsInvokedInOrder()
  {
    // Arrange
    var callbacks = new List<string>();
    var actionSub = () => callbacks.Add("action");
    var funcSub = () =>
    {
      callbacks.Add("func");
      return Task.CompletedTask;
    };

    // Act
    var cut = Render(@<FamilyTree TreeId="test" 
                                  AfterFamilyTreeRender=@actionSub
                                  AfterFamilyTreeRenderAsync=@funcSub />);

    // Arrange
    Assert.Equal("action", callbacks[0]);
    Assert.Equal("func", callbacks[1]);
  }
}
